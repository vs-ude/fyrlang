/**************************************************
 *
 * A simple implementation for Malloc and Free.
 * This implementation uses libc malloc.
 *
 **************************************************/

// Import functions from libc
extern "C" {
    func calloc(count uint64, size uint64) mut #byte
    func free(ptr mut #byte)
    func exit(status int)
}

// Each malloc'ed area starts with this header, which implements a linked list.
// This list contains all malloc'ed areas belonging to a memory group.
// Consequently, a pointer to the first header of this list is a pointer to the memory group.
type groupHeader struct {
    next mut #groupHeader
    // This value is only meaningful for the first item in the list
    last mut #groupHeader
}

// Malloc allocates memory and attaches it to a memory group.
// `group` is a pointer to a memory group handle.
// Initialliy `*group` can be zero.
// After Malloc returns, `*group` is a non-zero handle to a memory group.
// If `*group` is not zero, the value of `*group` does not change.
// Malloc returns a pointer to an area that is large enough for `count * size` bytes.
// Allocating 0 bytes is currently a fatal error.
func Malloc(count uint64, size uint64, group mut #uintptr) mut #byte {
    // Clear the lower bit of the handle to derived a pointer to the memory group
    g := `mut #byte(*group &^ 1)
    // TODO: Check for overflow
    s := count * size + `uint64(`groupHeader`.size)    
    alloc := calloc(1, s)
    if alloc == null {
        exit(1)
    }    
    // Add the allocated area to the group (if groupIn is not null)
    if g == null {
        *group = `uintptr(alloc)
        headerOut := `mut #groupHeader(alloc)
        headerOut.last = headerOut
    } else {
        headerIn := `mut #groupHeader(g)
        headerOut := `mut #groupHeader(alloc)
        headerIn.last.next = headerOut
        headerIn.last = headerOut
    }
    return alloc + `uintptr(`groupHeader`.size)
}

// Free releases all memory associated with a memory group.
// `group` ist either null or a memory group as set by `Malloc`.
func Free(group uintptr) {
    // If the lower bit has been set, the handle can still be used for malloc, but
    // the handle should do nothing upon calling Free.
    if group & 1 != 0 {
        return
    }
    // We assume that `h.prev == null` when the loop starts, i.e.
    // `h` points to the first entry in the list.
    for h := `mut #groupHeader(group); h != null; {
        h2 := h.next
        free(`mut #byte(h))
        h = h2
    }
}

// Merge unites two groups into one and returns the united group pointer for convenience.
// `group1` and `group2` can be null and they can point to the same group.
// If `group1` is not null, the function returns `group1`.
func Merge(group1 uintptr, group2 uintptr) uintptr {
    // Clear the lower bit of the handle to derived a pointer to the memory group
    g1 := `mut #byte(group1 &^ 1)
    g2 := `mut #byte(group2 &^ 1)
    if g1 == null {
        return group2
    }
    if g2 == null {
        return group1
    }
    if g1 == g2 {
        return group1
    }
    header1 := `mut #groupHeader(g1)
    header2 := `mut #groupHeader(g2)
    header1.last.next = header2
    header1.last = header2.last
    return group1
}