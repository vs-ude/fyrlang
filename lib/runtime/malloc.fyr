/**************************************************
 *
 * A simple implementation for Malloc and Free.
 * This implementation uses libc malloc.
 *
 **************************************************/

// Import functions from libc
extern "C" {
    func calloc(count uint64, size uint64) mut #byte
    func free(ptr mut #byte)
    func exit(status int)
}

// Each malloc'ed area starts with this header, which implements a linked list.
// This list contains all malloc'ed areas belonging to a memory group.
// Consequently, a pointer to the first header of this list is a pointer to the memory group.
type groupHeader struct {
    next mut #groupHeader
    // This value is only meaningful for the first item in the list
    last mut #groupHeader
}

// Malloc allocates memory and attaches it to a memory group.
// `group` is a pointer to a memory group pointer.
// Initialliy `*group` can be null.
// After Malloc returns, `*group` is pointing to a memory group.
// If `*group` is not null, the value of `*group` does not change.
// Malloc returns a pointer to an area that is large enough for `count * size` bytes.
// Allocating 0 bytes is currently a fatal error.
func Malloc(count uint64, size uint64, group mut # mut #byte) mut #byte {
    // TODO: Check for overflow
    s := count * size + `uint64(`groupHeader`.size)    
    alloc := calloc(1, s)
    if alloc == null {
        exit(1)
    }    
    // Add the allocated area to the group (if groupIn is not null)
    if *group == null {
        *group = alloc
        headerOut := `mut #groupHeader(alloc)
        headerOut.last = headerOut
    } else {
        headerIn := `mut #groupHeader(*group)
        headerOut := `mut #groupHeader(alloc)
        headerIn.last.next = headerOut
        headerIn.last = headerOut
    }
    return alloc + `uint64(`groupHeader`.size)
}

// Free releases all memory associated with a memory group.
// `group` ist either null or a memory group as set by `Malloc`.
func Free(group mut #byte) {
    // We assume that `h.prev == null` when the loop starts, i.e.
    // `h` points to the first entry in the list.
    for h := `mut #groupHeader(group); h != null; {
        h2 := h.next
        free(`mut #byte(h))
        h = h2
    }
}

// Merge unites two groups into one and returns the united group pointer for convenience.
// `group1` and `group2` can be null and they can point to the same group.
// If `group1` is not null, the function returns `group1`.
func Merge(group1 mut #byte, group2 mut #byte) mut #byte {
    if group1 == null {
        return group2
    }
    if group2 == null {
        return group1
    }
    if group1 == group2 {
        return group1
    }
    header1 := `mut #groupHeader(group1)
    header2 := `mut #groupHeader(group2)
    header1.last.next = header2
    header1.last = header2.last
    return group1
}