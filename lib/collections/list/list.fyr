type List<T> struct {
    first *Element<T>
    last *Element<T>
    count int
}

type Element<T> struct {
    Value T
    prev *element<T>
    next *element<T>
}

func dual *List.First() dual *Element<T> {
    return this.first
}

func dual *List.Last() dual *Element<T> {
    return this.last
}

func *List.Size() int {
    return this.count
}

func mut *List.Clear() {
    // TODO: Store the old elements for later use?
    this.last = null
    this.first = null
    this.count = 0
}

func *List.IsEmpty() bool {
    return this.count == 0
}

func mut *List.Push(value T) {
    let e *Element<T> = {Value: value, prev: this.last}
    if this.last != null {
        this.last.next = e
    } else {
        this.first = e
    }
    this.last = e
    this.count++
}

func mut *List.Pop() T {
    last := this.last
    if this.last == this.first {
        this.first = null
        this.last = null
        this.count = 0
    } else {
        this.last = this.last.prev
        this.last.next = null
        this.count--
    }
    return take(last.Value)
}

// func List.Shift(value T) {
// }

// func List.Unshift() T {
// }

func dual *List.At(pos int) dual *Element<T> {
    e := this.first
    for i := 0; i < pos && e != nil; i++ {
        e = e.next
    }
    return e
}

// Erases the element from the list and returns the next element in the list.
func mut *List.Erase(it *Element<T>) *Element<T> {
    // TODO: Reclaim the removed element
    next := take(it.next)
    prev := take(it.prev)
    if prev == null {
        if it != this.first {
            println("Iterator on wrong list")
        }
        if next == null {
            this.last = null
            this.first = null
        } else {
            this.first = next
            this.first.prev = null
        }
        this.count--
        return this.first
    } else if next == null {
        if it != this.last {
            println("Iterator on wrong list")
        }
        this.last = prev
        this.last.next = null
        this.count--
        return null
    }
    prev.next = next
    next.prev = prev
    this.count--
    return next
}

func mut *List.Concat(l mut *List) {
    if this.first == null {
        this.first = take(l.first)
        this.last = take(l.last)
        this.count = take(l.count)
        return
    }
    if l.first == null {
        return
    }
    e := take(l.first)
    e.prev = this.last
    this.last.next = e
    this.last = take(l.last)
    this.count += take(l.count)
}


func dual *Element.Next() dual *Element {
    return this.next
}

func dual *Element.Prev() dual *Element {
    return this.prev
}

func main() int {
    var l List`<int> = {}
    l.Push(42)
    l.Push(43)
    println("List completed")
    for it := l.Front(); it != nil; it = it.Next()) {
        println(it.Value)
    }
    for it := l.Front(); it != nil; it = it.Next()) {
        it.Value += 10
        it.Value
    }
    for it := l.Front(); it != nil; it = it.Next()) {
        println(it.Value)
    }
    println("Done")
    return 0
}