type List<T> struct {
    first *element<T>
    last *element<T>
    count int
}

type Element<T> struct {
    Value T
    prev *element<T>
    next *element<T>
}

func dual List.Front() dual *Element<T> {
    return this.first
}

func dual List.Back() dual *Element<T> {
    return this.last
}

func List.Size() int {
    return this.count
}

func mut List.Clear() {
    // TODO: Store the old elements for later use?
    this.last = null
    this.first = null
    this.count = 0
}

func List.IsEmpty() bool {
    return this.count == 0
}

func mut List.Push(value T) {
    let e *Element<T> = {Value: value, prev: this.last}
    if this.last != null {
        this.last.next = e
    } else {
        this.first = e
    }
    this.last = e
    this.count++
}

func mut List.Pop() T {
    last := this.last
    if this.last == this.first {
        this.first = null
        this.last = null
        this.count = 0
    } else {
        this.last = this.last.prev
        this.last.next = null
        this.count--
    }
    return take(last.Value)
}

// func List.Shift(value T) {
// }

// func List.Unshift() T {
// }

func dual List.At(pos int) dual *Element<T> {
    e := this.first
    for i := 0; i < pos; i++ {
        e = e.next
    }
    return e
}

func mut List.Erase(it *Element<T>) *Element<T> {
    if it.prev == null {
        if it != this.first {
            println("Iterator on wrong list")
        }
        if it.next == null {
            this.last = null
            this.first = null
        } else {
            this.first = take(it.next)
            this.first.prev = null
        }
        return this.first
    } else if it.next == null {
        if it != this.last {
            println("Iterator on wrong list")
        }
        this.last = take(it.prev)
        this.last.next = null
        return null
    }
    next := take(it.next)
    prev := take(it.prev)
    prev.next = next
    next.prev = prev
    return next
}

func mut List.Remove(it *Element<T>) (*Element<T>, T) {
    if it.prev == null {
        if it != this.first {
            println("Iterator on wrong list")
        }
        if it.next == null {
            this.last = null
            this.first = null
        } else {
            this.first = take(it.next)
            this.first.prev = null
        }
        return this.first, take(it.Balue)
    } else if it.next == null {
        if it != this.last {
            println("Iterator on wrong list")
        }
        this.last = take(it.prev)
        this.last.next = null
        return null, take(it.Value)
    }
    next := take(it.next)
    prev := take(it.prev)
    prev.next = next
    next.prev = prev
    return next, take(it.Value)
}

func mut List.Concat(l mut *List<T>) {
    if this.first == null {
        this.first = take(l.first)
        this.last = take(l.last)
        return
    }
    if l.first == null {
        return
    }
    e := take(l.first)
    e.prev = this.last
    this.last.next = e
    this.last = take(l.last)
}


func dual Element.Next() dual *Element {
    return this.next
}

func dual Element.Prev() dual *Element {
    return this.next
}

func main() int {
    var l List`<int> = {}
    l.Push(42)
    l.Push(43)
    println("List completed")
    for it := l.Front(); it != nil; it = it.Next()) {
        println(it.Value)
    }
    for it := l.Front(); it != nil; it = it.Next()) {
        it.Value += 10
        it.Value
    }
    for it := l.Front(); it != nil; it = it.Next()) {
        println(it.Value)
    }
    println("Done")
    return 0
}