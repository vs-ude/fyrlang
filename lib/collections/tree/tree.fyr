type Node<T> struct {
    Value T
    parent ~Node<T>
    children []*Node<T>
}

func dual Node.Parent() dual *Node<T> {
    return this.parent
}

func dual Node.At(pos int) dual *Node<T> {
    return this.children[pos]
}

func Node.Size() int {
    return len(this.children)
}

func Node.IndexOf(node *Node<T>) int {
    for let i, n in this.children {
        if n == node {
            return i
        }
    }
    return -1
}

func mut Node.Clear() {
    this.children = this.children[0:0]
}

func mut Node.RemoveAt(pos int) mut *Node<T> {
    let n = take(this.children[pos])
    move(this.children[pos:], this.children[pos + 1:])
    this.children = this.children[:len(this.children) - 1]
    n.parent = null
    return n
}

func mut Node.Remove(node *Node<T>) {
    let i = this.IndexOf(node)
    if i == -1 {
        return null
    }
    this.RemoveAt(i)
}

func mut Node.ReplaceAt(pos int, newNode *Node<T>) *Node<T> {
    if newNode.parent != null {
        newNode.parent.Remove(newNode)
    }
    newNode.parent = this
    let n = this.children[pos]
    this.children[pos] = newNode
    n.parent = null
    return n
}

func mut Node.ReplaceNode(oldNode *Node<T>, newNode *Node<T>) {
    let i = this.IndexOf(oldNode)
    if i == -1 {
        return
    }
    this.ReplaceAt(i, newNode)
}

func mut Node.Append(node *Node<T>) {
    node.parent = this
    this.children = append(this.children, node)
}

func mut Node.InsertAt(pos int, node *Node<T>) {
    if node.parent != null {
        node.parent.Remove(node)
    }
    node.parent = this
    this.children = append(this.children, null)
    move(this.children[pos + 1:], this.children[pos:])
}

func Iterator.Traverse() {
    if (this.Node == null) {
        return
    }
    if (len(this.Node.children) > 0) {
        this.Node = this.Node.children[0]
        return
    }
    for (this.Node.parent != null) {
        let i = this.Node.parent.IndexOf(this.Node) + 1
        if (i < len(this.Node.parent.children)) {
            this.Node = this.Node.parent.children[i]
            return
        }
        this.Node = this.Node.parent
    }
    this.Node = null
}

func main() int {
    let root *Node<int> = {Value: 42}
    let child *Node<int> = {Value: 10}
    child2 := child
    child.Append({Value: 11})
    child.Append({Value: 12})
    child.Append({Value: 13})
    root.Append(child)
    root.Append({Value: 20})
    root.Append({Value: 30})
    println(root.Size())
    println(root.IndexOf(child2))
    for it := root.First(); it != null; it = it.Next() {
        println(it.Value)
    }
    for it := root; it != null; it = it.Traverse()) {
        println(it.Value)
    }
    it := root.First()
    it = root.Erase(it)
    println(it.Value
    return 0
}
