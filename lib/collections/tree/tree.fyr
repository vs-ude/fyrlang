type Node<T> struct {
    Value T
    parent *Node
    first *Node
    last *Node
    count int
    prev *Node
    next *Node
}

func dual *Node.Parent() dual *Node {
    return this.parent
}

func dual *Node.At(pos int) dual *Node {
    n := this.first
    for i := 0; i < pos && n != nil; i++, n = n.next {
    }
    return n
}

// Returns the number of children
func *Node.Size() int {
    return this.count
}

func *Node.IndexOf(node *Node) int {
    n := this.first
    for i := 0; n != nil; i++, n = n.next {
        if node == n {
            return i
        }
    }
    return -1
}

func mut *Node.Clear() {
    // TODO: Reclaim removed Nodes
    this.prev = null
    this.next = null
    this.count = 0
}

func *Node.IsEmpty() bool {
    return this.count == 0
}

func mut *Node.RemoveAt(pos int) mut *Node {
    this.Remove(this.At(pos))
}

// Removes the node from its parent and returns the next sibling of the removed node.
// The removed node can be reused, it is now a root node.
func mut *Node.Remove(node *Node) *Node {
    if it.parent != this {
        println("Wrong parent")
    }
    it.parent = nil
    next := take(it.next)
    prev := take(it.prev)
    if prev == null {
        if it != this.first {
            println("Iterator on wrong list")
        }
        if next == null {
            this.last = null
            this.first = null
        } else {
            this.first = next
            this.first.prev = null
        }
        this.count--
        return this.first
    } else if next == null {
        if it != this.last {
            println("Iterator on wrong list")
        }
        this.last = prev
        this.last.next = null
        this.count--
        return null
    }
    prev.next = next
    next.prev = prev
    this.count--
    return next
}

// Replaces the node at its parent and returns the replaced node.
// The replaced node can be reused, it is now a root node.
func mut *Node.ReplaceAt(pos int, newNode *Node) *Node {
    n := this.At(pos)
    this.Replace(n, newNode)
    return n
}

func mut *Node.Replace(oldNode *Node, newNode *Node) {
    if oldNode.parent != this {
        println("Wrong parent")
    }
    if newNode.parent != null {
        newNode.parent.Remove(newNode)
    }
    newNode.parent = take(oldNode.parent)
    newNode.next = take(oldNode.next)
    newNode.prev = take(oldNode.prev)
    if newNode.next != null {
        newNode.next.prev = newNode
    }
    if newNode.prev != null {
        newNode.prev.next = newNode
    }
}

func mut *Node.Push(node *Node) {
    if node.parent != null {
        node.parent.Remove(node)
    }
    node.parent = this
    node.next = null
    node.prev = this.last
    this.last = node
    if this.first == null {
        this.first = node
    }
    this.count++
}

func mut *Node.Pop() *Node {
    last := this.last
    if this.last == this.first {
        this.first = null
        this.last = null
        this.count = 0
    } else {
        this.last = this.last.prev
        this.last.next = null
        this.count--
    }
    return last
}

func dual *Node.Traverse() *Node {
    if this.first != null {
        return this.first
    }
    if this.parent == null {
        return null
    }
    for n := this; n != nil; n = n.parent {
        if n.next != null {
            return n.next
        }
    }
    return null
}

// Returns the next sibling
func dual *Node.Next() dual *Node {
    return this.next
}

// Returns the previous sibling
func dual *Node.Prev() dual *Node {
    return this.prev
}

// Returns the first child
func dual *Node.First() dual *Node {
    return this.first
}

// Returns the last child
func dual *Node.Last() dual *Node {
    return this.last
}
