component TestMe

import {
    "./test/demo"
}

type Kind Kind2
type Kind2 int

type Ptr mut *int

type IfaceBase interface{
    func mut *Add(i int) int
    func *ToInt() int
}

type Iface interface{
    IfaceBase
    func *Print()
}

type B struct {
}

type S struct {
    B
    Iface
    field int
    arr []Kind 
    name [256]int
    myptr :grp *B
}

type Callback func(a int, b int) int

type Generic<X,Y> struct {
    a *X
    b *Y
}

type G1 Generic`<int, int>
type G2 Generic`<int, int>

type Point struct {
    X int
    Y int
}

var a int
let c int = 5

func UseDemo() *demo.DemoStruct {

}

func DoMe() *Generic`<S, B> {
    // Hello comment
}

func DoMe2(ptr *Generic`<int, int>) {
    // Hello comment
}

func B.PrintMe() demo.Gini`<int> {   
}

func *B.PrintMePtr() {   
}

func mut *B.MutMe(ptr :grp *S) {   
}

func *Generic.CallMe(p X) {
}

func Log<X, Y>(a X) Y {
}

func Expr(a int) {
    true || false
    var b bool
    b && (true || b)    
    // GEN "foo"!= "dudel"
    a == 5
    a != 5
    // `uint(a)
    var x int = 10
    // GEN x++
    var y uint64 = 0xffffffffffffffff
    i := 5
    y = 2
    var alpha, beta = -1, 2
    var gamma, delta float32 = 1, -3.4
    let ptr mut *B = null
    let ptr2 :grp *B = ptr
    var p Point
    // GEN let px, py = p
    var arr [3]int
    arr[2]
    // a[:6], a[7:], a[:], a[x:y]    
    let ax, ay, az = arr
    let bx, by, bz int = arr
    // GEN let spx, spy int = p
    x, cy, cz := arr
    // GEN cpx, cy := p
    x, y = 4, 0    
    var z, zz int
    // GEN x, z = p
    // GEN x, z, zz = arr
    // GEN arr = [1, 2, 3]
    var matrix [3][3]int
    matrix[1][2] = 42
    matrix[1][2]
    var slice []int
    slice[2]
}